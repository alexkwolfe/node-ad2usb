// Generated by CoffeeScript 1.4.0
(function() {
  var Alarm, BufferStream, EventEmitter, Socket,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  BufferStream = require('bufferstream');

  EventEmitter = require('events').EventEmitter;

  Socket = require('net').Socket;

  Alarm = (function(_super) {
    var panelMessageRegex, rfMessageRegex, sendingRegex;

    __extends(Alarm, _super);

    function Alarm(socket) {
      var _this = this;
      this.socket = socket;
      this.handleData = __bind(this.handleData, this);

      this.buffer = new BufferStream({
        encoding: 'utf8',
        size: 'flexible'
      });
      this.buffer.split('\n', function(message) {
        return _this.handleMessage(message.toString('ascii'));
      });
      this.socket.on('data', this.handleData);
    }

    /*
      Internal: Handle a chunk of data sent by the AD2SUB interface by writing it to the buffer.
    */


    Alarm.prototype.handleData = function(data) {
      return this.buffer.write(data.toString('ascii'));
    };

    /*
      Internal: A message has been received and must be handled.
      msg: String message sent by the AD2USB interface.
    */


    panelMessageRegex = /^\[/;

    rfMessageRegex = /^!RFX/;

    sendingRegex = /^!Sending(\.*)done/;

    Alarm.prototype.handleMessage = function(msg) {
      if (msg.match(panelMessageRegex)) {
        return this.handlePanelData(msg);
      } else if (msg.match(rfMessageRegex)) {
        return this.handleRfMessage(msg);
      } else if (msg.match(sendingRegex)) {
        return this.emit('sent');
      }
    };

    /*
      Internal: Panel data has been received. Parse it, keep state, and emit events when state changes.
    */


    Alarm.prototype.handlePanelData = function(msg) {
      var beeps, parts, sec1, sec2, sec3;
      parts = msg.split(',');
      sec1 = parts[0].replace(/[\[\]]/g, '').split('');
      this.state('disarmed', sec1.shift() === '1');
      this.state('armedAway', sec1.shift() === '1');
      this.state('armedStay', sec1.shift() === '1');
      this.state('backlight', sec1.shift() === '1');
      this.state('programming', sec1.shift() === '1');
      beeps = parseInt(sec1.shift(), 10);
      if (beeps > 0) {
        this.emit('beeps', beeps);
      }
      this.state('bypass', sec1.shift() === '1');
      this.state('power', sec1.shift() === '1');
      this.state('chimeMode', sec1.shift() === '1');
      this.state('alarmOccured', sec1.shift() === '1');
      this.state('alarm', sec1.shift() === '1');
      this.state('batteryLow', sec1.shift() === '1');
      this.state('entryDelayOff', sec1.shift() === '1');
      this.state('fireAlarm', sec1.shift() === '1');
      this.state('checkZone', sec1.shift() === '1');
      this.state('perimeterOnly', sec1.shift() === '1');
      sec2 = parts[1];
      this.faultedZone = sec2;
      sec3 = parts[3].replace(/[\[\]]/g, '');
      return this.raw = sec3;
    };

    /*
      Internal: A RF sensor has reported its status. Parse it, keep state and emit events when state changes.
    */


    Alarm.prototype.handleRfMessage = function(msg) {
      var parts, serial, status;
      parts = msg.replace('!RFX:', '').split(',');
      serial = parts.shift();
      status = parseInt(parts.shift(), 16).toString(2).split('');
      status = {
        battery: status[1] === '1',
        supervision: status[2] === '1',
        loop1: status[7] === '1',
        loop2: status[5] === '1',
        loop3: status[4] === '1',
        loop4: status[6] === '1'
      };
      state("zone:" + serial, status.supervision);
      state("battery:" + serial, status.battery);
      return state("loop:" + serial, [status.loop1, status.loop2, status.loop3, status.loop4]);
    };

    /*
    */


    Alarm.prototype.state = function(name, state) {
      var changed;
      changed = this[name] !== state;
      if (changed) {
        this[name] = state;
        this.emit(name, state);
      }
      return changed;
    };

    /*
      Internal: Send a command to the AD2USB interface.
    
      code: String command to send (i.e. "12341")
      callback: function invoked when interface acknowledges command (optional)
    
      Returns true if command is sent, otherwise false.
    */


    Alarm.prototype.send = function(cmd, callback) {
      this.once('sent', function(msg) {
        if (callback) {
          return callback(null, msg);
        }
      });
      return this.socket.write(cmd);
    };

    Alarm.prototype.armAway = function(code, callback) {
      return this.send("" + code + "2", callback);
    };

    Alarm.prototype.armStay = function(code, callback) {
      return this.send("" + code + "3", callback);
    };

    Alarm.prototype.disarm = function(code, callback) {
      return this.send("" + code + "1", callback);
    };

    Alarm.prototype.bypass = function(code, zone, callback) {
      return this.send("" + code + "5" + zone, callback);
    };

    /*
      Public: Connect to the AD2USB device using a TCP socket.
    
      ip: String IP address of interface
      port: Integer TCP port of interface (optional, defaults to 4999)
      callback: invoked once the connection has been established (optional)
    */


    Alarm.connect = function() {
      var alarm, args, callback, ip, port, socket, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (typeof args[args.length - 1] === 'function') {
        callback = args.pop();
      }
      ip = args.shift();
      port = (_ref = args.shift()) != null ? _ref : 10001;
      socket = new Socket({
        type: 'tcp4'
      });
      alarm = new Alarm(socket);
      socket.connect(port, ip, callback);
      return alarm;
    };

    return Alarm;

  })(EventEmitter);

  module.exports = Alarm;

}).call(this);
